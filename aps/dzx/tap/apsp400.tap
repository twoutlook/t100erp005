<add_points prog="apsp400" std_prog="apsp400" erpver="1.0" module="APS" ver="1" env="s" zone="t10dev" booking="Y">
  <point name="function.apsp400_psba001_chk" cite_std="N" status="" ver="1" src="s" new="Y" order="1" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: MDS編號檢查
# Memo...........:
# Usage..........: CALL apsp400_psba001_chk(p_psba001)
#                  RETURNING r_success
# Input parameter: p_psba001      MDS編號
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/16 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_psba001_chk(p_psba001)
DEFINE p_psba001         LIKE psba_t.psba001
DEFINE r_success         LIKE type_t.num5

   LET r_success = TRUE
   
   IF cl_null(p_psba001) THEN
      RETURN r_success
   END IF
   
   INITIALIZE g_chkparam.* TO NULL
   LET g_chkparam.arg1 = p_psba001
   IF NOT cl_chk_exist("v_psba001") THEN
      LET r_success = FALSE
      RETURN r_success
   END IF
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_psba001_ref" cite_std="N" status="" ver="1" src="s" new="Y" order="2" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 抓取MDS編號說明
# Memo...........:
# Usage..........: CALL apsp400_psba001_ref(p_psba001)
#                  
# Input parameter: p_psba001      MDS編號
#                : 
# Return code....: 
#                : 
# Date & Author..: 2014/03/16 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_psba001_ref(p_psba001)
DEFINE p_psba001         LIKE psba_t.psba001
DEFINE l_psba001_desc    LIKE psbal_t.psbal003
DEFINE l_psba            RECORD LIKE psba_t.*

   INITIALIZE g_ref_fields TO NULL
   LET g_ref_fields[1] = p_psba001
   CALL ap_ref_array2(g_ref_fields,"SELECT psbal003 FROM psbal_t WHERE psbalent='"||g_enterprise||"' AND psbal001=? AND psbal002='"||g_dlang||"'","") RETURNING g_rtn_fields
   LET l_psba001_desc = '', g_rtn_fields[1] , ''
   DISPLAY l_psba001_desc TO psba001_desc
   
   INITIALIZE l_psba.* TO NULL
   SELECT * INTO l_psba.* 
     FROM psba_t
    WHERE psbaent = g_enterprise
      AND psba001 = p_psba001
   
   DISPLAY BY NAME l_psba.psba002,l_psba.psba003,l_psba.psba004,l_psba.psba005,l_psba.psba006,
                   l_psba.psba007,l_psba.psba008,l_psba.psba009,l_psba.psba010,l_psba.psba011,
                   l_psba.psba012,l_psba.psba013,l_psba.psba014,l_psba.psba015,l_psba.psba016,
                   l_psba.psba017,l_psba.psba018,l_psba.psba019,l_psba.psba020,l_psba.psba021,
                   l_psba.psba022,l_psba.psba023,l_psba.psba024,l_psba.psba025,l_psba.psba026,
                   l_psba.psba027,l_psba.psba028,l_psba.psba029,l_psba.psba030
                   
   IF l_psba.psba016 = '4' THEN
      #自訂時距
      CALL apsp400_b_fill(l_psba.psba001) 
   END IF
END FUNCTION]]>
</point>
  <point name="function.apsp400_del_mds" cite_std="N" status="" ver="1" src="s" new="Y" order="3" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 刪除MDS舊有資料
# Memo...........:
# Usage..........: CALL apsp400_del_mds()
#                  RETURNING r_success
# Input parameter: 
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/18 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_del_mds()
DEFINE r_success         LIKE type_t.num5

   LET r_success = TRUE
  
   #MDS淨需求檔
   DELETE FROM psbb_t 
    WHERE psbbent = g_enterprise
      AND psbb001 = g_psba.psba001
   IF SQLCA.sqlcode THEN
      CALL cl_errmsg('del psbb',g_psba.psba001,'',SQLCA.sqlcode,1)
      LET r_success = FALSE
   END IF
   
   #MDS銷售預測沖銷單頭檔
   DELETE FROM psbc_t
    WHERE psbcent = g_enterprise
      AND psbc001 = g_psba.psba001
   IF SQLCA.sqlcode THEN
      CALL cl_errmsg('del psbc',g_psba.psba001,'',SQLCA.sqlcode,1)
      LET r_success = FALSE
   END IF
   
   #MDS銷售預測沖銷單身檔
   DELETE FROM psbd_t
    WHERE psbdent = g_enterprise
      AND psbd001 = g_psba.psba001
   IF SQLCA.sqlcode THEN
      CALL cl_errmsg('del psbd',g_psba.psba001,'',SQLCA.sqlcode,1)
      LET r_success = FALSE
   END IF
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_get_forecast" cite_std="N" status="" ver="1" src="s" new="Y" order="4" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 取得銷售預測資料
# Memo...........:
# Usage..........: CALL apsp400_get_forecast(p_base_date)
#                  RETURNING r_success
# Input parameter: p_base_date    計算基準日
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/19 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_get_forecast(p_base_date)
DEFINE p_base_date       LIKE type_t.dat
DEFINE r_success         LIKE type_t.num5
DEFINE l_sql             STRING
DEFINE l_imaa006         LIKE imaa_t.imaa006
DEFINE l_xmig016         LIKE xmig_t.xmig016

   LET r_success = TRUE
   IF cl_null(p_base_date) THEN
      RETURN r_success
   END IF
   
   #需求來源-銷售預測 = 'N'
   IF cl_null(g_psba.psba002) OR g_psba.psba002 = 'N' THEN
      RETURN r_success
   END IF
   
   #抓取銷售預測資料
   LET l_sql = "SELECT xmig001,xmig002,xmig003,xmig004,xmig005,xmig006,xmig007,xmig008,xmig009, ",
               "       xmig010,xmig011,xmig012,xmig013,xmig017,xmig018,xmig016 ",
               "  FROM xmig_t ",
               " WHERE xmigent = ",g_enterprise,
               "   AND xmigsite= '",g_site,"'",
               "   AND xmig001 = '",g_psba.psba007,"'",
               "   AND xmig002 = (SELECT MAX(xmig002) FROM xmig_t ",
               "                   WHERE xmigent = ",g_enterprise,
               "                     AND xmigsite= '",g_site,"'",
               "                     AND xmig001 = '",g_psba.psba007,"')",
               "   AND xmig012 >= '",p_base_date,"'"
   
   PREPARE forecast_pre FROM l_sql
   DECLARE forecast_cs CURSOR FOR forecast_pre
   
   FOREACH forecast_cs INTO g_forecast.*,l_xmig016
      IF SQLCA.sqlcode THEN
         CALL cl_errmsg("FOREACH forecast_cs","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
      
      IF g_psba.psba009 = '2' THEN
         LET g_forecast.quantity = l_xmig016
      END IF
      
      #單位轉換為基礎單位
      SELECT imaa006 INTO l_imaa006 FROM imaa_t
       WHERE imaaent = g_enterprise
         AND imaa001 = g_forecast.xmig006
         
      #訂單換算成基礎單位的數量
      CALL s_aooi250_convert_qty(g_forecast.xmig006,g_forecast.xmig018,l_imaa006,g_forecast.quantity)
           RETURNING r_success,g_forecast.quantity
      IF NOT r_success THEN
         EXIT FOREACH
      END IF
      
      LET g_forecast.xmig018 = l_imaa006
      
      INSERT INTO forecast_tmp VALUES (g_forecast.*)
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg("ins forecast",g_forecast.xmig001,"",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_get_order" cite_std="N" status="" ver="1" src="s" new="Y" order="5" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 取得訂單/預先訂單資料
# Memo...........:
# Usage..........: CALL apsp400_get_order(p_base_date)
#                  RETURNING r_success
# Input parameter: p_base_date    計算基準日
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/18 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_get_order(p_base_date)
DEFINE p_base_date       LIKE type_t.dat
DEFINE r_success         LIKE type_t.num5
DEFINE l_sql             STRING
DEFINE l_imaa006         LIKE imaa_t.imaa006

   LET r_success = TRUE
   IF cl_null(p_base_date) THEN
      RETURN r_success
   END IF
   
   IF g_psba.psba003 = 'N' AND g_psba.psba004 = 'N' THEN
      RETURN r_success
   END IF
   
   #抓取訂單資料
   LET l_sql = "SELECT xmdadocno,xmda002,xmda003,xmda004,xmda023, ",
               "       xmddseq,xmddseq1,xmddseq2,xmdd001,xmdd002, ",
               "       xmdd004,(xmdd006-xmdd014+xmdd015) amt,xmdd011, ",
               "       xmdd013 ",
               "  FROM xmda_t,xmdc_t,xmdd_t ",
               " WHERE xmdaent = xmdcent ",
               "   AND xmdadocno = xmdcdocno ",
               "   AND xmdaent = xmddent ",
               "   AND xmdadocno = xmdddocno ",
               "   AND xmdcseq = xmddseq ",
               "   AND xmdaent = ",g_enterprise,
               "   AND xmdcunit= '",g_site,"'",    #出貨地點
               "   AND xmda019 = 'Y' ",            #納入MRP計算
               "   AND xmdastus= 'Y' ",            #已確認訂單
               "   AND xmdd017 <> '5' ",           #單身未結案
               "   AND (xmdd006 - xmdd014 + xmdd015) > 0 "
   #逾交訂單是否納入
   IF g_psba.psba011 = 'Y' THEN
      LET l_sql = l_sql CLIPPED," AND xmdd011 >= '",p_base_date-g_psba.psba012,"'"
   ELSE
      LET l_sql = l_sql CLIPPED," AND xmdd011 >= '",p_base_date,"'"
   END IF
   
   #預先訂單='N'
   IF g_psba.psba004 = 'N' THEN
      LET l_sql = l_sql CLIPPED," AND xmda005 <> '7' "
   END IF
   
   #訂單='N'
   IF g_psba.psba003 = 'N' THEN
      LET l_sql = l_sql CLIPPED," AND xmda005 = '7' "
   END IF
               
   PREPARE order_pre FROM l_sql
   DECLARE order_cs CURSOR FOR order_pre
   
   FOREACH order_cs INTO g_order.*
      IF SQLCA.sqlcode THEN
         CALL cl_errmsg("FOREACH order_cs","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
      
      #訂單單位轉為基礎單位
      SELECT imaa006 INTO l_imaa006 FROM imaa_t
       WHERE imaaent = g_enterprise
         AND imaa001 = g_order.xmdd001
      
      #訂單換算成基礎單位的數量
      CALL s_aooi250_convert_qty(g_order.xmdd001,g_order.xmdd004,l_imaa006,g_order.quantity)
           RETURNING r_success,g_order.quantity
      IF NOT r_success THEN
         EXIT FOREACH
      END IF
      
      LET g_order.xmdd004 = l_imaa006
      
      INSERT INTO order_tmp VALUES (g_order.*)
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg("ins order",g_order.xmdadocno,"",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_contra" cite_std="N" status="" ver="1" src="s" new="Y" order="6" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 預測與訂單沖銷
# Memo...........:
# Usage..........: CALL apsp400_contra(p_base_date)
#                  RETURNING r_success
# Input parameter: p_base_date    計算基準日
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/18 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_contra(p_base_date)
DEFINE p_base_date       LIKE type_t.dat
DEFINE r_success         LIKE type_t.num5
DEFINE l_sql             STRING
DEFINE l_psbc            RECORD LIKE psbc_t.*
DEFINE l_cnt             LIKE type_t.num5
DEFINE l_xmia011         LIKE xmia_t.xmia011
DEFINE l_xmia012         LIKE xmia_t.xmia012
DEFINE l_xmia013         LIKE xmia_t.xmia013
DEFINE l_xmia014         LIKE xmia_t.xmia014
DEFINE L_xmia015         LIKE xmia_t.xmia015
DEFINE l_ooed002         LIKE ooed_t.ooed002
DEFINE l_ooed003         LIKE ooed_t.ooed003 
DEFINE l_psbc002         LIKE psbc_t.psbc002
DEFINE l_psbc003         LIKE psbc_t.psbc003
DEFINE l_psbc004         LIKE psbc_t.psbc004
DEFINE l_psbc005         LIKE psbc_t.psbc005
DEFINE l_psbc006         LIKE psbc_t.psbc006
DEFINE l_psbc007         LIKE psbc_t.psbc007
DEFINE l_psbc008         LIKE psbc_t.psbc008
DEFINE l_psbc012         LIKE psbc_t.psbc012
DEFINE l_psbc013         LIKE psbc_t.psbc013
DEFINE l_forecast_quantity LIKE psbc_t.psbc012
DEFINE l_order_quantity  LIKE xmdd_t.xmdd006
DEFINE l_quantity        LIKE xmdd_t.xmdd006
DEFINE l_psbd019         LIKE psbd_t.psbd019
DEFINE l_current_time    DATETIME YEAR TO SECOND

   LET r_success = TRUE
   IF cl_null(p_base_date) THEN
      RETURN r_success
   END IF
   
   #先做來源為業務預測資料的沖銷，再做計畫性下階料的沖銷
   #業務預測的沖銷要考慮沖銷條件，計畫性下階料直接以料號做沖銷
   LET l_sql = "SELECT * FROM forecast_tmp ",
               " ORDER BY xmig017 "
   PREPARE forecast_tmp_pre FROM l_sql
   DECLARE forecast_tmp_cs CURSOR FOR forecast_tmp_pre
   
   FOREACH forecast_tmp_cs INTO g_forecast.*
      IF SQLCA.sqlcode THEN
         CALL cl_errmsg("FOREACH forecast_tmp","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
      
      LET l_forecast_quantity = g_forecast.quantity
      
      #當資料不存在時，新增MDS預測沖銷單頭檔(psbc_t)
      LET l_cnt = 0
      SELECT COUNT(*) INTO l_cnt FROM psbc_t
       WHERE psbcent = g_enterprise
         AND psbcsite= g_site
         AND psbc001 = g_psba.psba001
         AND psbc002 = g_forecast.xmig004
         AND psbc003 = g_forecast.xmig005
         AND psbc004 = g_forecast.xmig006
         AND psbc005 = g_forecast.xmig007
         AND psbc006 = g_forecast.xmig008
         AND psbc007 = g_forecast.xmig009
         AND psbc008 = g_forecast.xmig010
      IF cl_null(l_cnt) OR l_cnt = 0 THEN
         #先將預測資料寫入MDS預測沖銷單頭檔(psbc_t)
         INITIALIZE l_psbc.* TO NULL
         LET l_psbc.psbc001 = g_psba.psba001
         LET l_psbc.psbc002 = g_forecast.xmig004
         LET l_psbc.psbc003 = g_forecast.xmig005
         LET l_psbc.psbc004 = g_forecast.xmig006
         LET l_psbc.psbc005 = g_forecast.xmig007
         LET l_psbc.psbc006 = g_forecast.xmig008
         LET l_psbc.psbc007 = g_forecast.xmig009
         LET l_psbc.psbc008 = g_forecast.xmig010
         LET l_psbc.psbc009 = g_forecast.xmig011
         LET l_psbc.psbc010 = g_forecast.xmig012
         LET l_psbc.psbc011 = g_psba.psba009
         LET l_psbc.psbc012 = l_forecast_quantity
         LET l_psbc.psbc013 = 0
         LET l_psbc.psbc014 = 0
         LET l_psbc.psbc015 = 0
         LET l_psbc.psbc016 = g_forecast.xmig001
         LET l_psbc.psbc017 = g_forecast.xmig002
         LET l_psbc.psbc018 = g_forecast.xmig003
         LET l_current_time = cl_get_current()
      
         INSERT INTO psbc_t (psbcent,psbcsite,psbc001,psbc002,psbc003,psbc004,psbc005,
                             psbc006,psbc007,psbc008,psbc009,psbc010,psbc011,psbc012,
                             psbc013,psbc014,psbc015,psbc016,psbc017,psbc018,psbc019)
            VALUES (g_enterprise,g_site,l_psbc.psbc001,l_psbc.psbc002,l_psbc.psbc003,
                    l_psbc.psbc004,l_psbc.psbc005,l_psbc.psbc006,l_psbc.psbc007,
                    l_psbc.psbc008,l_psbc.psbc009,l_psbc.psbc010,l_psbc.psbc011,
                    l_psbc.psbc012,l_psbc.psbc013,l_psbc.psbc014,l_psbc.psbc015,
                    l_psbc.psbc016,l_psbc.psbc017,l_psbc.psbc018,l_current_time)
         IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
            CALL cl_errmsg('ins psbc_t',l_psbc.psbc001,'',SQLCA.sqlcode,1)
            LET r_success = FALSE
            EXIT FOREACH
         END IF
      END IF
      
      #若起始日期小於等於無效預測日的話，就不管預測資料
      IF g_forecast.xmig012 <= p_base_date + g_psba.psba010 THEN
         #將預測數量更新到MDS預測沖銷單頭檔(psbc_t)內的無效數量
         UPDATE psbc_t SET psbc013 = psbc013 + l_psbc.psbc012
          WHERE psbcent = g_enterprise
            AND psbcsite= g_site
            AND psbc001 = g_psba.psba001
            AND psbc002 = g_forecast.xmig004
            AND psbc003 = g_forecast.xmig005
            AND psbc004 = g_forecast.xmig006
            AND psbc005 = g_forecast.xmig007
            AND psbc006 = g_forecast.xmig008
            AND psbc007 = g_forecast.xmig009
            AND psbc008 = g_forecast.xmig010
         IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
            CALL cl_errmsg('upd psbc_t',l_psbc.psbc001,'',SQLCA.sqlcode,1)
            LET r_success = FALSE
            EXIT FOREACH
         END IF
         CONTINUE FOREACH
      END IF
      
      #依預測類型抓取訂單數量
      LET l_order_quantity = 0
      IF g_forecast.xmig017 = '1' THEN
         #1.業務預測
         
         #訂單數量
         LET l_sql = "SELECT * FROM order_tmp ",
                     " WHERE xmdd001 IN (SELECT imaf001 FROM imaf_t ",
                     "                    WHERE imafent = ",g_enterprise,
                     "                      AND imafsite= '",g_site,"'",
                     "                      AND imaf125 = '",g_forecast.xmig006,"')",
                     "   AND xmdd011 BETWEEN '",g_forecast.xmig011,"' AND '",g_forecast.xmig012,"' "
         
         #判斷預測方式可沖銷
         SELECT xmia011,xmia012,xmia013,xmia014,xmia015
           INTO l_xmia011,l_xmia012,l_xmia013,l_xmia014,l_xmia015
           FROM xmia_t
          WHERE xmiaent = g_enterprise
            AND xmia001 = g_forecast.xmig001
           
         #預測組織
         IF l_xmia011 = 'Y' THEN
            SELECT DISTINCT ooed002,ooed003 INTO l_ooed002,l_ooed003
              FROM ooed_t
             WHERE ooedent = g_enterprise
               AND ooed001 = '7'
               AND ooed004 = g_forecast.xmig004
               AND ooed006 <= p_base_date
               AND (ooed007 > p_base_date OR ooed007 IS NULL)
            LET l_sql = l_sql CLIPPED," AND xmda003 IN (SELECT ooed004 FROM ooed_t ",
                                      "                  WHERE ooedent = ",g_enterprise,
                                      "                    AND ooed001 = '7' ",
                                      "                    AND ooed002 = '",l_ooed002,"'",
                                      "                    AND ooed003 = '",l_ooed003,"'",
                                      "                CONNECT BY ooed005 = prior ooed004 ",
                                      "                  START WITH ooed005 = '",g_forecast.xmig004,"')"
         END IF
         
         #客戶
         IF l_xmia012 = 'Y' THEN
            LET l_sql = l_sql CLIPPED," AND xmda004 = '",g_forecast.xmig008,"'"
         END IF
         
         #通路
         IF l_xmia013 = 'Y' THEN
            LET l_sql = l_sql CLIPPED," AND xmda023 = '",g_forecast.xmig009,"'"
         END IF
         
         #業務員
         IF l_xmia014 = 'Y' THEN
            LET l_sql = l_sql CLIPPED," AND xmda002 = '",g_forecast.xmig005,"'"
         END IF
         
         #產品特徵
         IF l_xmia015 = 'Y' THEN
            LET l_sql = l_sql CLIPPED," AND xmdd002 = '",g_forecast.xmig007,"'"
         END IF
  
      ELSE
         #2.計畫性下階料
         
         #直接依料號抓取未沖銷訂單數量
         LET l_sql = "SELECT * FROM order_tmp ",
                     " WHERE pmdd001 IN (SELECT imaf001 FROM imaf_t ",
                     "                    WHERE imafent = ",g_enterprise,
                     "                      AND imafsite= '",g_site,"'",
                     "                      AND imaf125 = '",g_forecast.xmig006,"')"
      END IF
      
      LET l_sql = l_sql CLIPPED," ORDER BY xmdd011 "
      
      PREPARE order_quantity_pre FROM l_sql
      DECLARE order_quantity_cs CURSOR FOR order_quantity_pre
      
      LET l_order_quantity = 0
      CALL g_order_day.clear()
      LET l_ac = 1
      FOREACH order_quantity_cs INTO g_order.*
      
         LET l_order_quantity = l_order_quantity + g_order.quantity
         
         #記錄該訂單的日期和數量，後續分配到天會用到
         LET g_order_day[l_ac].date = g_order.xmdd011
         LET g_order_day[l_ac].qty  = g_order.quantity
         LET l_ac = l_ac + 1
      
         #記錄預測資料是被哪些訂單沖銷，
         #把抓到的訂單資料寫入MDS銷售預測單身檔內
         INSERT INTO psbd_t (psbdent,psbdsite,psbd001,psbd002,psbd003,psbd004,psbd005,
                             psbd006,psbd007,psbd008,psbd009,psbd010,psbd011,psbd012,
                             psbd013,psbd014,psbd015,psbd016,psbd017,psbd018,psbd019,
                             psbd020)
             VALUES (g_enterprise,g_site,g_psba.psba001,g_forecast.xmig004,g_forecast.xmig005,
                     g_forecast.xmig006,g_forecast.xmig007,g_forecast.xmig008,g_forecast.xmig009,
                     g_forecast.xmig010,g_order.xmdadocno,g_order.xmddseq,g_order.xmddseq1,
                     g_order.xmddseq2,g_order.xmda003,g_order.xmda002,g_order.xmdd001,
                     g_order.xmdd002,g_order.xmda004,g_order.xmda023,g_order.quantity,
                     g_order.xmdd011)
         IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
            CALL cl_errmsg('ins psbd_t','','',SQLCA.sqlcode,1)
            LET r_success = FALSE
            EXIT FOREACH
         END IF
         
      END FOREACH
      
      IF NOT r_success THEN
         EXIT FOREACH
      END IF
      
      #比較預測數量與訂單數量，訂單較大者不做處理，預測較大者，則將預測超出訂單的數量寫入淨需求檔內
      IF l_forecast_quantity > l_order_quantity THEN
         
         #將沖銷後預測量做分配到天的動作，並將分配到天的資料寫入淨需求檔內
         CALL apsp400_apportion(l_forecast_quantity,l_order_quantity)
              RETURNING r_success
         IF NOT r_success THEN
            EXIT FOREACH
         END IF
      END IF
      
   END FOREACH
    
   #更新MDS銷售預測沖銷單頭檔的訂單沖銷量=訂單數量
   #及預測剩餘量=預測量-無效量-訂單沖銷量，如果小於0時，則更改為0 
   DECLARE psbc_cs CURSOR FOR
    SELECT psbc002,psbc003,psbc004,psbc005,psbc006,psbc007,psbc008,
           psbc012,psbc013
      FROM psbc_t
     WHERE psbcent = g_enterprise
       AND psbcsite= g_site
       AND psbc001 = g_psba.psba001
   FOREACH psbc_cs INTO l_psbc002,l_psbc003,l_psbc004,l_psbc005,l_psbc006,l_psbc007,l_psbc008,
                        l_psbc012,l_psbc013
      
      LET l_psbd019 = 0
      SELECT SUM(psbd019) INTO l_psbd019
        FROM psbd_t
       WHERE psbdent = g_enterprise
         AND psbdsite= g_site
         AND psbd001 = g_psba.psba001
         AND psbd002 = l_psbc002
         AND psbd003 = l_psbc003
         AND psbd004 = l_psbc004
         AND psbd005 = l_psbc005
         AND psbd006 = l_psbc006
         AND psbd007 = l_psbc007
         AND psbd008 = l_psbc008
      IF cl_null(l_psbd019) THEN
         LET l_psbd019 = 0
      END IF
      
      LET l_quantity = l_psbc012 - l_psbc013 - l_psbd019
      IF l_quantity < 0 THEN
         LET l_quantity = 0
      END IF
      
      UPDATE psbc_t SET psbc014 = l_psbd019,
                        psbc015 = l_quantity
       WHERE psbcent = g_enterprise
         AND psbcsite= g_site
         AND psbc001 = g_psba.psba001
         AND psbc002 = l_psbc002
         AND psbc003 = l_psbc003
         AND psbc004 = l_psbc004
         AND psbc005 = l_psbc005
         AND psbc006 = l_psbc006
         AND psbc007 = l_psbc007
         AND psbc008 = l_psbc008
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg('upd psbc_t','','',SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH

   #把訂單寫入淨需求檔
   CALL apsp400_order_ins_psbb()
        RETURNING r_success
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_apportion" cite_std="N" status="" ver="1" src="s" new="Y" order="7" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 預測量分配到天
# Memo...........:
# Usage..........: CALL apsp400_apportion(p_forecast_qty,p_order_qty)
#                  RETURNING r_success
# Input parameter: p_forecast_qty 預測量
#                : p_order_qty    訂單數量
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/20 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_apportion(p_forecast_qty,p_order_qty)
DEFINE p_forecast_qty    LIKE psbb_t.psbb006
DEFINE p_order_qty       LIKE psbb_t.psbb006
DEFINE r_success         LIKE type_t.num5
DEFINE l_qty             LIKE psbb_t.psbb006       #沖銷後數量
DEFINE l_qty1            LIKE psbb_t.psbb006       #當天/週還可分配的預測量
DEFINE l_qty2            LIKE psbb_t.psbb006       #當天還可分配的預測量
DEFINE l_ooef008         LIKE ooef_t.ooef008       #行事曆參照表號
DEFINE l_ooef009         LIKE ooef_t.ooef009       #製造行事曆對應類別
DEFINE l_workdays        LIKE type_t.num5          #起始日期到截止日期的工作天
DEFINE l_workdays1       LIKE type_t.num5          #需求預測的實際需要的工作天
DEFINE l_imae017         LIKE imae_t.imae017       #生產批量
DEFINE l_imae018         LIKE imae_t.imae018       #最小生產數量
DEFINE l_carry           LIKE psbb_t.psbb006       #依料件的生產批量及最小生產數量去得出最小生產數量
DEFINE l_num             LIKE psbb_t.psbb006       #計算的過渡
DEFINE l_num1            LIKE type_t.num5          #計算的過渡
DEFINE l_workday_qty     LIKE psbb_t.psbb006       #每個工作天的預測需求量
DEFINE l_remainder       LIKE psbb_t.psbb006       #餘量
DEFINE l_firstday_qty    LIKE psbb_t.psbb006       #第一天的工作量
DEFINE l_lastday_qty     LIKE psbb_t.psbb006       #最後一天的工作量
DEFINE l_first_workdate  LIKE type_t.dat           #第一天工作天的日期
DEFINE l_last_workdate   LIKE type_t.dat           #最後一天工作天的日期
DEFINE l_order_remainder LIKE psbb_t.psbb006       #在最後一天工作天之後的訂單量
DEFINE l_order_qty       LIKE psbb_t.psbb006       #當日/週訂單量
DEFINE l_workdate        LIKE psbb_t.psbb007       #當日日期
DEFINE l_i               LIKE type_t.num5
DEFINE l_j               LIKE type_t.num5
DEFINE l_ac              LIKE type_t.num5
DEFINE l_week_day        LIKE type_t.num5          #當週的工作天
DEFINE l_week_qty        LIKE psbb_t.psbb006       #當週的預測量
DEFINE l_denominator     LIKE type_t.num20_6       #分攤百分比-分母
DEFINE l_molecular       DYNAMIC ARRAY OF LIKE type_t.num20_6       #分攤百分比-分子
DEFINE l_day_qty         DYNAMIC ARRAY OF RECORD   #當週工作天的分配預測量
         date            LIKE type_t.dat,
         qty             LIKE psbb_t.psbb006
                         END RECORD
DEFINE l_week_totqty     LIKE psbb_t.psbb006       #當週累計的分配預測量
DEFINE l_product         LIKE type_t.num5        
DEFINE l_ooga002         LIKE ooga_t.ooga002
DEFINE l_oogc008         LIKE oogc_t.oogc008
DEFINE l_oogc015         LIKE oogc_t.oogc015
DEFINE l_min_date        LIKE type_t.dat
DEFINE l_max_date        LIKE type_t.dat
DEFINE l_date            LIKE type_t.dat
DEFINE l_cnt             LIKE type_t.num5


   LET r_success = TRUE
   
   LET l_qty = p_forecast_qty - p_order_qty
   IF l_qty <= 0 THEN
      RETURN r_success
   END IF
   
   #抓取行事曆參照表號及製造行事曆對應類別
   SELECT ooef008,ooef009 INTO l_ooef008,l_ooef009
     FROM ooef_t
    WHERE ooefent = g_enterprise
      AND ooef001 = g_site
   
   #取得起始日期到截止日期的工作天
   LET l_first_workdate = g_forecast.xmig011 - 1
   CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_first_workdate,g_forecast.xmig012)
        RETURNING l_workdays
   LET l_workdays = l_workdays
   
   IF g_psba.psba021 = '1' THEN
      #依料件最小生產數量與批量進位:
      
      #1.抓取生產批量、最小生產數量
      SELECT imae017,imae018 INTO l_imae017,l_imae018
        FROM imae_t
       WHERE imaeent = g_enterprise
         AND imaesite= g_site
         AND imae001 = g_forecast.xmig006
      #2.依生產批量、最小生產數量去計算最小生產數量
      CALL s_num_round('4',l_imae018/l_imae017,0)
           RETURNING l_product
      LET l_carry = l_imae018 * l_product
   ELSE
      #數量進位指定量
      LET l_imae017 = g_psba.psba022
      LET l_carry = g_psba.psba022
   END IF
   
   #計算每天可工作量:
   #1.計算每天可工作量(未進位)
   LET l_num = g_forecast.quantity / l_workdays
   #2.進位
   IF l_num <= l_carry THEN
      LET l_workday_qty = l_carry
   ELSE
      CALL s_num_round('4',l_num/l_imae017,0)
           RETURNING l_num1
      LET l_workday_qty = l_num1 * l_imae017
   END IF
   
   #花費的工作天
   CALL s_num_round('4',g_forecast.quantity/l_workday_qty,0)
        RETURNING l_workdays1
        
   #餘量
   LET l_remainder = (l_workday_qty*l_workdays1) - g_forecast.quantity
   IF l_remainder <> 0 THEN
      LET l_remainder = l_workday_qty - l_remainder
   END IF
   
   #餘量歸屬
   IF l_remainder > 0 THEN 
      IF g_psba.psba023 = '1' THEN
         #最後一天
         LET l_lastday_qty = l_remainder
         LET l_firstday_qty= l_workday_qty
      ELSE
         #第一天
         LET l_firstday_qty= l_workday_qty + l_remainder
         LET l_lastday_qty = l_workday_qty
         LET l_workdays1 = l_workdays1 - 1
      END IF
   ELSE
      LET l_firstday_qty= l_workday_qty
      LET l_lastday_qty = l_workday_qty
   END IF
   
   #最後一天花費的工作天的日期
   CALL s_date_get_work_date(g_site,l_ooef008,l_ooef009,l_first_workdate,0,l_workdays1)
        RETURNING l_last_workdate
   
   #在花費的工作天之後的訂單量
   LET l_order_remainder = 0
   FOR l_i = g_order_day.getLength() TO 1 STEP -1
      IF cl_null(g_order_day[l_i].date) THEN
         CONTINUE FOR
      END IF
      IF g_order_day[l_i].date > l_last_workdate THEN
         LET l_order_remainder = l_order_remainder + g_order_day[l_i].qty
         LET l_ac = l_i
      ELSE
         LET l_ac = l_i
         EXIT FOR
      END IF
      IF l_j = 0 THEN
         LET l_ac = 0
      END IF
   END FOR
   
   #預測需求分攤方式
   IF g_psba.psba020 = '1' THEN
      #依工作天數平均分攤
      FOR l_i = l_workdays1 TO 1 STEP -1
         LET l_order_qty = 0
         IF l_ac > 0 THEN
            CALL s_date_get_work_date(g_site,l_ooef008,l_ooef009,l_first_workdate,0,l_i)
                 RETURNING l_workdate
            FOR l_j = l_ac TO 1 STEP -1
               #當天訂單量
               IF l_workdate = g_order_day[l_j].date THEN
                  LET l_order_qty = g_order_day[l_j].qty
               ELSE
                  LET l_ac = l_j
                  EXIT FOR
               END IF
            END FOR
         END IF
            
         #當天可分配量 - 當天訂單量 - 訂單剩餘量
         CASE 
            WHEN l_i = l_workdays1
                 #最後一天            
                 LET l_qty1 = l_lastday_qty - l_order_qty - l_order_remainder
            WHEN l_i = 1
                 #第一天
                 LET l_qty1 = l_firstday_qty - l_order_qty - l_order_remainder
            OTHERWISE
                 LET l_qty1 = l_workday_qty - l_order_qty - l_order_remainder
         END CASE
            
         #若大於0，表示當天還可分配的預測量
         IF l_qty1 > 0 THEN
            CALL s_date_get_work_date(g_site,l_ooef008,l_ooef009,l_first_workdate,0,l_i)
                 RETURNING l_workdate
            IF l_qty > l_qty1 THEN
               #若尚未分配的預測量 > 當天還可分配的預測量，則將當天還可分配的預測量新增進淨需求檔(psbb_t)
               CALL apsp400_forecast_ins_psbb(l_workdate,l_qty1)
                    RETURNING r_success
               IF NOT r_success THEN
                  EXIT FOR
               END IF
               LET l_qty = l_qty - l_qty1
            ELSE
               #若尚未分配的預測量 <=當天還可分配的預測量，則將尚未分配的預測量新增進淨需求檔(psbb_t)
               CALL apsp400_forecast_ins_psbb(l_workdate,l_qty)
                    RETURNING r_success
               EXIT FOR
            END IF
            #訂單剩餘量
            LET l_order_remainder = 0
         ELSE
            #訂單剩餘量
            LET l_order_remainder = l_qty1 * (-1)
         END IF
      END FOR
   ELSE
      #依工作天數進行週分攤
      DECLARE oogc_cs CURSOR FOR
       SELECT DISTINCT oogc008,oogc015 
         FROM oogc_t
        WHERE oogcent = g_enterprise
          AND oogc001 = l_ooef008
          AND oogc002 = l_ooef009
          AND oogc003 > l_first_workdate
          AND oogc003 <= l_last_workdate
        ORDER BY oogc008 DESC
      
      FOREACH oogc_cs INTO l_oogc008,l_oogc015
         
         CALL l_day_qty.clear()
         
         #本週的起始日、截止日
         SELECT MIN(oogc003),MAX(oogc003)
           INTO l_min_date,l_max_date
           FROM oogc_t
          WHERE oogcent = g_enterprise
            AND oogc001 = l_ooef008
            AND oogc002 = l_ooef009
            AND oogc008 = l_oogc008
            AND oogc015 = l_oogc015
            
         LET l_min_date = l_min_date - 1
#         IF l_first_workdate > l_min_date THEN
#            LET l_min_date = l_first_workdate
#         END IF
#         
#         IF l_last_workdate < l_max_date THEN
#            LET l_max_date = l_last_workdate 
#         END IF
                        
         #當週訂單量
         LET l_order_qty = 0
         IF l_ac >= 1 THEN
            FOR l_j = l_ac TO 1 STEP -1
               IF cl_null(g_order_day[l_j].date) THEN
                  CONTINUE FOR
               END IF
#               IF g_order_day[l_j].date >= l_min_date THEN
               IF g_order_day[l_j].date > l_min_date THEN
                  LET l_order_qty = l_order_qty + g_order_day[l_j].qty
               ELSE
                  LET l_ac = l_j
                  EXIT FOR
               END IF
            END FOR
            IF l_j = 0 THEN
               LET l_ac = 0
            END IF
         END IF
         
         #當週分配的天數
         
         CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_min_date,l_max_date)
              RETURNING l_week_day
                
         #當週的可分配量
         LET l_week_qty = 0
         CASE 
            WHEN l_min_date > l_first_workdate AND l_max_date < l_last_workdate
                 CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_min_date,l_max_date)
                      RETURNING l_week_day
            WHEN l_min_date <= l_first_workdate AND l_max_date < l_last_workdate
                 CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_first_workdate,l_max_date)
                      RETURNING l_week_day
                 LET l_week_day = l_week_day - 1
                 LET l_week_qty = l_firstday_qty
            WHEN l_min_date > l_first_workdate AND l_max_date >= l_last_workdate
                 CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_min_date,l_last_workdate)
                      RETURNING l_week_day
                 LET l_week_day = l_week_day - 1
                 LET l_week_qty = l_lastday_qty
            WHEN l_min_date <= l_first_workdate AND l_max_date >= l_last_workdate
                 CALL s_date_get_workdays(g_site,l_ooef008,l_ooef009,l_first_workdate,l_last_workdate)
                      RETURNING l_week_day
                 LET l_week_day = l_week_day - 2
                 LET l_week_day = l_firstday_qty + l_lastday_qty
         END CASE
         LET l_week_qty = l_week_qty + l_week_day * l_workday_qty
         
         #剩餘預測量
         LET l_qty1 = l_week_qty - l_order_qty - l_order_remainder
            
         #若大於0，表示當週還可分配的預測量
         IF l_qty1 > 0 THEN
            
            IF l_qty > l_qty1 THEN
               #若尚未分配的預測量 > 當週還可分配的預測量，則將當週還可分配的預測量新增進淨需求檔(psbb_t)
               LET l_qty = l_qty - l_qty1 
            ELSE
               #若尚未分配的預測量 <=當週還可分配的預測量，則將尚未分配的預測量新增進淨需求檔(psbb_t)
               LET l_qty1 = l_qty
               LET l_qty = 0
            END IF
            
            #當週的工作天百分比-分母
            LET l_denominator = 0
            LET l_cnt = l_max_date - l_min_date + 1
            FOR l_i = 1 TO l_cnt
               CALL s_date_get_date(l_min_date,0,l_i)
                    RETURNING l_date
                 
               #確認日期是否為工作天
               IF s_date_chk_workday(g_site,l_ooef008,l_ooef009,l_date) THEN
                  #該日期為星期?
                  SELECT ooga002 INTO l_ooga002 
                    FROM ooga_t
                   WHERE oogaent = g_enterprise
                     AND ooga001 = l_date
                  CASE l_ooga002
                     WHEN '1'
                          LET l_denominator = l_denominator + g_psba.psba024
                          LET l_molecular[l_i] = g_psba.psba024
                     WHEN '2'
                          LET l_denominator = l_denominator + g_psba.psba025
                          LET l_molecular[l_i] = g_psba.psba025
                     WHEN '3'
                          LET l_denominator = l_denominator + g_psba.psba026
                          LET l_molecular[l_i] = g_psba.psba026
                     WHEN '4'
                          LET l_denominator = l_denominator + g_psba.psba027
                          LET l_molecular[l_i] = g_psba.psba027
                     WHEN '5'
                          LET l_denominator = l_denominator + g_psba.psba028
                          LET l_molecular[l_i] = g_psba.psba028
                     WHEN '6'
                          LET l_denominator = l_denominator + g_psba.psba029
                          LET l_molecular[l_i] = g_psba.psba029
                     WHEN '0'
                          LET l_denominator = l_denominator + g_psba.psba030
                          LET l_molecular[l_i] = g_psba.psba030
                  END CASE
               ELSE
                  LET l_molecular[l_i] = 0
               END IF
            END FOR

            #將預測未沖銷數量依比率分給當週的每一個工作天
            LET l_remainder = 0
            FOR l_i = 1 TO l_cnt
               #若該天分配比率=0，就不分配
               IF l_molecular[l_i] = 0 THEN
                  CONTINUE FOR
               END IF
            
               CALL s_date_get_date(l_min_date,0,l_i)
                    RETURNING l_date
               IF NOT s_date_chk_workday(g_site,l_ooef008,l_ooef009,l_date) THEN
                  CONTINUE FOR
               END IF
#               #小於起始日期，就不計算
#               IF l_date < l_first_workdate THEN
#                  CONTINUE FOR
#               END IF
#               #大於截止日期，就不計算
#               IF l_date > l_last_workdate THEN
#                  EXIT FOR
#               END IF
               
               LET l_qty2 = l_qty1 * l_molecular[l_i]/l_denominator
               IF l_qty2 <= l_carry THEN
                  LET l_qty2 = l_carry
               ELSE
                  CALL s_num_round('4',l_qty2/l_imae017,0)
                       RETURNING l_num1
                  LET l_qty2 = l_num1 * l_imae017
               END IF
              
               LET l_week_totqty = l_week_totqty + l_qty2
               IF l_week_totqty > l_qty1 THEN
                  #餘量
                  LET l_remainder = l_qty2
                  EXIT FOR
               ELSE
                  LET l_day_qty[l_i].date= l_date
                  LET l_day_qty[l_i].qty = l_qty2
               END IF
            END FOR
         
            #餘量歸屬
            IF l_remainder > 0 THEN 
               IF g_psba.psba023 = '1' THEN
                  #最後一天
                  LET l_day_qty[l_i+1].date = l_day_qty[l_i].date
                  LET l_day_qty[l_i+1].qty = l_remainder
               ELSE
                  #第一天
                  LET l_day_qty[1].qty = l_day_qty[1].qty+l_remainder
               END IF
            END IF
            
            FOR l_i = 1 TO l_day_qty.getLength() 
               IF cl_null(l_day_qty[l_i].date) THEN
                  CONTINUE FOR
               END IF
               CALL apsp400_forecast_ins_psbb(l_day_qty[l_i].date,l_day_qty[l_i].qty)
                    RETURNING r_success
               IF NOT r_success THEN
                  EXIT FOR
               END IF
            END FOR
            
            IF NOT r_success THEN
               EXIT FOREACH
            END IF
            
            #訂單剩餘量
            LET l_order_remainder = 0
            IF l_qty = 0 THEN
               EXIT FOREACH
            END IF
         ELSE
            #訂單剩餘量
            LET l_order_remainder = l_qty1 * (-1)
         END IF
      END FOREACH
   END IF
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_create_temptable" cite_std="N" status="" ver="1" src="s" new="Y" order="8" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: Create銷售預測及訂單的Temp Table
# Memo...........:
# Usage..........: CALL apsp400_create_temptable()
#                  RETURNING r_success
# Input parameter: 
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/19 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_create_temptable()
DEFINE r_success         LIKE type_t.num5

   LET r_success = TRUE
   
   DROP TABLE forecast_tmp
   CREATE TEMP TABLE forecast_tmp(
      xmig001        LIKE xmig_t.xmig001,
      xmig002        LIKE xmig_t.xmig002,
      xmig003        LIKE xmig_t.xmig003,
      xmig004        LIKE xmig_t.xmig004,
      xmig005        LIKE xmig_t.xmig005,
      xmig006        LIKE xmig_t.xmig006,
      xmig007        LIKE xmig_t.xmig007,
      xmig008        LIKE xmig_t.xmig008,
      xmig009        LIKE xmig_t.xmig009,
      xmig010        LIKE xmig_t.xmig010,
      xmig011        LIKE xmig_t.xmig011,
      xmig012        LIKE xmig_t.xmig012,
      quantity       LIKE xmig_t.xmig013,
      xmig017        LIKE xmig_t.xmig017,
      xmig018        LIKE xmig_t.xmig018)
   IF SQLCA.sqlcode THEN
      CALL cl_err('create forecast_tmp',SQLCA.sqlcode,1)
      LET r_success = FALSE
      RETURN r_success
   END IF
   
   DROP TABLE order_tmp
   CREATE TEMP TABLE order_tmp(
      xmdadocno      LIKE xmda_t.xmdadocno,
      xmda002        LIKE xmda_t.xmda002,
      xmda003        LIKE xmda_t.xmda003,
      xmda004        LIKE xmda_t.xmda004,
      xmda023        LIKE xmda_t.xmda023,
      xmddseq        LIKE xmdd_t.xmddseq,
      xmddseq1       LIKE xmdd_t.xmddseq1,
      xmddseq2       LIKE xmdd_t.xmddseq2,
      xmdd001        LIKE xmdd_t.xmdd001,
      xmdd002        LIKE xmdd_t.xmdd002,
      xmdd004        LIKE xmdd_t.xmdd004,
      quantity       LIKE xmdd_t.xmdd006,
      xmdd011        LIKE xmdd_t.xmdd011,
      xmdd013        LIKE xmdd_t.xmdd013)
   IF SQLCA.sqlcode THEN
      CALL cl_err('create order_tmp',SQLCA.sqlcode,1)
      LET r_success = FALSE
      RETURN r_success
   END IF
      
   DROP TABLE sort_tmp
   CREATE TEMP TABLE sort_tmp(
      sort1          LIKE type_t.num5,
      psbbdocno      LIKE psbb_t.psbbdocno,
      psbbseq        LIKE psbb_t.psbbseq,
      psbbseq1       LIKE psbb_t.psbbseq1,
      psbbseq2       LIKE psbb_t.psbbseq2,
      psbb001        LIKE psbb_t.psbb001,
      psbb002        LIKE psbb_t.psbb002,
      psbb007        LIKE psbb_t.psbb007,
      psbb008        LIKE psbb_t.psbb008,
      oocq009        LIKE oocq_t.oocq009, 
      xmdc020        LIKE xmdc_t.xmdc020)
   IF SQLCA.sqlcode THEN
      CALL cl_err('create sort_tmp',SQLCA.sqlcode,1)
      LET r_success = FALSE
      RETURN r_success
   END IF
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_b_fill" cite_std="N" status="u" ver="1" src="s" new="Y" order="9" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 抓取MDS計算策略自定時距檔
# Memo...........:
# Usage..........: CALL apsp400_b_fill(p_psba001)
#                  
# Input parameter: p_psba001      MDS編號
#                : 
# Return code....:
#                : 
# Date & Author..: 2014/03/16 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_b_fill(p_psba001)
DEFINE p_psba001         LIKE psba_t.psba001

   DECLARE sel_psbe_cs CURSOR FOR
    SELECT psbe002,psbe003 FROM psbe_t
     WHERE psbeent = g_enterprise
       AND psbe001 = p_psba001
       
   CALL g_psbe.clear()
   
   LET l_ac = 1
   FOREACH sel_psbe_cs INTO g_psbe[l_ac].psbe002,g_psbe[l_ac].psbe003
      IF SQLCA.sqlcode THEN
         CALL cl_err("FOREACH:",SQLCA.sqlcode,1)
         EXIT FOREACH
      END IF

      LET l_ac = l_ac + 1
      IF l_ac > g_max_rec THEN
         EXIT FOREACH
      END IF
   END FOREACH
   
   LET l_ac = l_ac - 1
   CALL g_psbe.deleteElement(g_psbe.getLength())
   
END FUNCTION]]>
</point>
  <point name="function.apsp400_forecast_ins_psbb" cite_std="N" status="" ver="1" src="s" new="Y" order="10" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 需求預測寫入淨需求檔
# Memo...........:
# Usage..........: CALL apsp400_forecast_ins_psbb(p_psbb007,p_psbb006)
#                  RETURNING r_success
# Input parameter: p_psbb007      需求日期
#                : p_psbb006      需求數量
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/24 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_forecast_ins_psbb(p_psbb007,p_psbb006)
DEFINE p_psbb007         LIKE psbb_t.psbb007
DEFINE p_psbb006         LIKE psbb_t.psbb006
DEFINE r_success         LIKE type_t.num5
DEFINE l_psbb            RECORD LIKE psbb_t.*

   LET r_success = TRUE
   
   INITIALIZE l_psbb.* TO NULL
   LET l_psbb.psbbdocno = 'FORCAST'
   LET l_psbb.psbb001 = g_psba.psba001
   SELECT MAX(psbbseq)+1 INTO l_psbb.psbbseq
     FROM psbb_t
    WHERE psbbent = g_enterprise
      AND psbbsite= g_site
      AND psbbdocno = l_psbb.psbbdocno
      AND psbb001 = l_psbb.psbb001
   IF cl_null(l_psbb.psbbseq) THEN
      LET l_psbb.psbbseq = 1
   END IF
   LET l_psbb.psbbseq1= 0
   LET l_psbb.psbbseq2= 0
   LET l_psbb.psbb002 = '2'
   LET l_psbb.psbb003 = g_forecast.xmig006
   LET l_psbb.psbb004 = g_forecast.xmig007
   LET l_psbb.psbb005 = g_forecast.xmig018
   LET l_psbb.psbb006 = p_psbb006
   LET l_psbb.psbb007 = p_psbb007
   LET l_psbb.psbb008 = g_forecast.xmig008
   LET l_psbb.psbb009 = g_forecast.xmig005
   LET l_psbb.psbb010 = g_forecast.xmig004
   LET l_psbb.psbb011 = g_forecast.xmig009
   LET l_psbb.psbb012 = ''
   LET l_psbb.psbb013 = 'N'
      
   INSERT INTO psbb_t (psbbent,psbbsite,psbbdocno,psbbseq,psbbseq1,psbbseq2,
                       psbb001,psbb002,psbb003,psbb004,psbb005,psbb006,psbb007,
                       psbb008,psbb009,psbb010,psbb011,psbb012,psbb013)
      VALUES (g_enterprise,g_site,l_psbb.psbbdocno,l_psbb.psbbseq,l_psbb.psbbseq1,
              l_psbb.psbbseq2,l_psbb.psbb001,l_psbb.psbb002,l_psbb.psbb003,
              l_psbb.psbb004,l_psbb.psbb005,l_psbb.psbb006,l_psbb.psbb007,
              l_psbb.psbb008,l_psbb.psbb009,l_psbb.psbb010,l_psbb.psbb011,
              l_psbb.psbb012,l_psbb.psbb013)
   IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
      CALL cl_errmsg('ins psbb_t','','',SQLCA.sqlcode,1)
      LET r_success = FALSE
   END IF
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_order_ins_psbb" cite_std="N" status="" ver="1" src="s" new="Y" order="11" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 訂單寫入淨需求檔
# Memo...........:
# Usage..........: CALL apsp400_order_ins_psbb()
#                  RETURNING r_success
# Input parameter: 
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/20 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_order_ins_psbb()
DEFINE r_success         LIKE type_t.num5
DEFINE l_psbb            RECORD LIKE psbb_t.*

   LET r_success = TRUE
   
   DECLARE order_cs1 CURSOR FOR
    SELECT * FROM order_tmp
  
   FOREACH order_cs1 INTO g_order.*
      INITIALIZE l_psbb.* TO NULL
      LET l_psbb.psbbdocno = g_order.xmdadocno
      LET l_psbb.psbbseq = g_order.xmddseq
      LET l_psbb.psbbseq1= g_order.xmddseq1
      LET l_psbb.psbbseq2= g_order.xmddseq2
      LET l_psbb.psbb001 = g_psba.psba001
      LET l_psbb.psbb002 = '1'
      LET l_psbb.psbb003 = g_order.xmdd001
      LET l_psbb.psbb004 = g_order.xmdd002
      LET l_psbb.psbb005 = g_order.xmdd004
      LET l_psbb.psbb006 = g_order.quantity
      LET l_psbb.psbb007 = g_order.xmdd011
      LET l_psbb.psbb008 = g_order.xmda004
      LET l_psbb.psbb009 = g_order.xmda002
      LET l_psbb.psbb010 = g_order.xmda003
      LET l_psbb.psbb011 = g_order.xmda023
      LET l_psbb.psbb012 = ''
      LET l_psbb.psbb013 = g_order.xmdd013
      
      INSERT INTO psbb_t (psbbent,psbbsite,psbbdocno,psbbseq,psbbseq1,psbbseq2,
                          psbb001,psbb002,psbb003,psbb004,psbb005,psbb006,psbb007,
                          psbb008,psbb009,psbb010,psbb011,psbb012,psbb013)
         VALUES (g_enterprise,g_site,l_psbb.psbbdocno,l_psbb.psbbseq,l_psbb.psbbseq1,
                 l_psbb.psbbseq2,l_psbb.psbb001,l_psbb.psbb002,l_psbb.psbb003,
                 l_psbb.psbb004,l_psbb.psbb005,l_psbb.psbb006,l_psbb.psbb007,
                 l_psbb.psbb008,l_psbb.psbb009,l_psbb.psbb010,l_psbb.psbb011,
                 l_psbb.psbb012,l_psbb.psbb013)
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg('ins psbb_t','','',SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_independent_demand" cite_std="N" status="" ver="1" src="s" new="Y" order="12" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 獨立需求新增到淨需求檔
# Memo...........:
# Usage..........: CALL apsp400_independent_demand()
#                  RETURNING r_success
# Input parameter: 
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/25 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_independent_demand()
DEFINE r_success         LIKE type_t.num5
DEFINE l_psbb            RECORD LIKE psbb_t.*
DEFINE l_psaadocno       LIKE psaa_t.psaadocno
DEFINE l_psabseq         LIKE psab_t.psabseq
DEFINE l_psab001         LIKE psab_t.psab001
DEFINE l_psab002         LIKE psab_t.psab002
DEFINE l_psab003         LIKE psab_t.psab003
DEFINE l_psab004         LIKE psab_t.psab004
DEFINE l_psab005         LIKE psab_t.psab005
DEFINE l_psab009         LIKE psab_t.psab009

   LET r_success = TRUE
   
   IF g_psba.psba005 = 'N' THEN
      RETURN r_success
   END IF
   
   DECLARE psab_cs CURSOR FOR
    SELECT psaadocno,psabseq,psab001,psab002,psab003,psab004,(psab005-psab006),psab009
      FROM psaa_t,psab_t
     WHERE psaaent = psabent
       AND psaadocno = psabdocno
       AND psaaent = g_enterprise
       AND psaasite= g_site
       AND psaastus = 'Y'
       AND psab008 = 'N'            #未結案
       AND (psab005 - psab006) > 0  #還有需求量
  
   FOREACH psab_cs INTO l_psaadocno,l_psabseq,l_psab001,l_psab002,l_psab003,l_psab004,
                        l_psab005,l_psab009
      INITIALIZE l_psbb.* TO NULL
      LET l_psbb.psbbdocno = l_psaadocno
      LET l_psbb.psbbseq = l_psabseq
      LET l_psbb.psbbseq1= 0
      LET l_psbb.psbbseq2= 0
      LET l_psbb.psbb001 = g_psba.psba001
      LET l_psbb.psbb002 = '3'
      LET l_psbb.psbb003 = l_psab001
      LET l_psbb.psbb004 = l_psab002
      #料件的基礎單位
      SELECT imaa006 INTO l_psbb.psbb005
        FROM imaa_t
       WHERE imaaent = g_enterprise
         AND imaa001 = l_psbb.psbb003
      
      #數量要轉換為料件基礎單位的數量
      CALL s_aooi250_convert_qty(l_psbb.psbb003,l_psab004,l_psbb.psbb005,l_psab005)
           RETURNING r_success,l_psbb.psbb006
      IF NOT r_success THEN
         EXIT FOREACH
      END IF
      
      LET l_psbb.psbb007 = l_psab003
      LET l_psbb.psbb008 = ''
      LET l_psbb.psbb009 = ''
      LET l_psbb.psbb010 = ''
      LET l_psbb.psbb011 = ''
      LET l_psbb.psbb012 = ''
      LET l_psbb.psbb013 = l_psab009
      
      INSERT INTO psbb_t (psbbent,psbbsite,psbbdocno,psbbseq,psbbseq1,psbbseq2,
                          psbb001,psbb002,psbb003,psbb004,psbb005,psbb006,psbb007,
                          psbb008,psbb009,psbb010,psbb011,psbb012,psbb013)
         VALUES (g_enterprise,g_site,l_psbb.psbbdocno,l_psbb.psbbseq,l_psbb.psbbseq1,
                 l_psbb.psbbseq2,l_psbb.psbb001,l_psbb.psbb002,l_psbb.psbb003,
                 l_psbb.psbb004,l_psbb.psbb005,l_psbb.psbb006,l_psbb.psbb007,
                 l_psbb.psbb008,l_psbb.psbb009,l_psbb.psbb010,l_psbb.psbb011,
                 l_psbb.psbb012,l_psbb.psbb013)
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg('ins psbb_t','','',SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_psbb_sort" cite_std="N" status="" ver="1" src="s" new="Y" order="13" mark_hard="N">
<![CDATA[################################################################################
# Descriptions...: 排列優先順序
# Memo...........:
# Usage..........: CALL apsp400_psbb_sort(p_base_date)
#                  RETURNING r_success
# Input parameter: p_base_date    計算基準日
#                : 
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/24 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_psbb_sort(p_base_date)
DEFINE p_base_date       LIKE type_t.dat
DEFINE r_success         LIKE type_t.num5
DEFINE l_ooef008         LIKE ooef_t.ooef008
DEFINE l_ooef009         LIKE ooef_t.ooef009
DEFINE l_min_date        LIKE type_t.dat
DEFINE l_max_date        LIKE type_t.dat
DEFINE l_date            LIKE type_t.dat
DEFINE l_oogc008         LIKE oogc_t.oogc008
DEFINE l_oogc015         LIKE oogc_t.oogc015
DEFINE l_min             LIKE type_t.dat
DEFINE l_max             LIKE type_t.dat
DEFINE l_day             LIKE type_t.num5
DEFINE l_month           LIKE type_t.num5
DEFINE l_days            LIKE type_t.num5
DEFINE l_i               LIKE type_t.num5
DEFINE l_date_t          LIKE type_t.dat
DEFINE l_psbe003         LIKE psbe_t.psbe003
DEFINE l_cnt             LIKE type_t.num5
DEFINE l_cnt1            LIKE type_t.num5

   LET r_success = TRUE
   LET g_psbb_sort = 0
   
   SELECT ooef008,ooef009 
     INTO l_ooef008,l_ooef009
     FROM ooef_t
    WHERE ooefent = g_enterprise
      AND ooef001 = g_site
   
   SELECT MIN(psbb007),MAX(psbb007) INTO l_min_date,l_max_date
     FROM psbb_t
    WHERE psbbent = g_enterprise
      AND psbbsite= g_site
      AND psbb001 = g_psba.psba001
   LET l_day = l_max_date - l_min_date + 1
   
   CASE g_psba.psba016
      WHEN '1'   #週
           FOR l_i = 1 TO l_day+7 STEP 7
              CALL s_date_get_date(l_min_date,0,l_i)
                   RETURNING l_date
              #本日的週別
              SELECT oogc008,oogc015 INTO l_oogc008,l_oogc015
                FROM oogc_t
               WHERE oogcent = g_enterprise
                 AND oogc001 = l_ooef008
                 AND oogc002 = l_ooef009
                 AND oogc003 = l_date
              #本週的起始日、截止日
              SELECT MIN(oogc003),MAX(oogc003)
                INTO l_min,l_max
                FROM oogc_t
               WHERE oogcent = g_enterprise
                 AND oogc001 = l_ooef008
                 AND oogc002 = l_ooef009
                 AND oogc008 = l_oogc008
                 AND oogc015 = l_oogc015
              #依據本週的起始日、截止日排序
              CALL apsp400_psbb_sort1(l_min,l_max)
                   RETURNING r_success
              IF NOT r_success THEN
                 EXIT FOR
              END IF
           END FOR
      WHEN '2'   #旬
           FOR l_i = 1 TO l_day+10 STEP 10
              CALL s_date_get_date(l_min_date,0,l_i)
                   RETURNING l_date
              CASE 
                 WHEN DAY(l_date) <= 10
                      LET l_min = MDY(MONTH(l_date),1,YEAR(l_date))
                      LET l_max = MDY(MONTH(l_date),10,YEAR(l_date))
                 WHEN (DAY(l_date) > 10 AND DAY(l_date) <= 20)
                      LET l_min = MDY(MONTH(l_date),11,YEAR(l_date))
                      LET l_max = MDY(MONTH(l_date),20,YEAR(l_date))
                 WHEN (DAY(l_date) > 20)
                      LET l_min = MDY(MONTH(l_date),21,YEAR(l_date))
                      CALL s_date_get_max_day(YEAR(l_date),MONTH(l_date))
                           RETURNING l_days
                      LET l_max = MDY(MONTH(l_date),l_days,YEAR(l_date))
              END CASE
              #依據本旬的起始日、截止日排序
              CALL apsp400_psbb_sort1(l_min,l_max)
                   RETURNING r_success
              IF NOT r_success THEN
                 EXIT FOR
              END IF
           END FOR
      WHEN '3'   #月
           LET l_date = l_min_date
           FOR l_month = MONTH(l_min_date) TO MONTH(l_max_date)
              LET l_min = MDY(l_month,1,YEAR(l_date))
              CALL s_date_get_max_day(YEAR(l_date),MONTH(l_date))
                   RETURNING l_days
              LET l_max = MDY(l_month,l_days,YEAR(l_date))
              LET l_date= l_date + l_days
              
              #依據本月的起始日、截止日排序
              CALL apsp400_psbb_sort1(l_min,l_max)
                   RETURNING r_success
              IF NOT r_success THEN
                 EXIT FOR
              END IF
           END FOR
      WHEN '4'   #自訂
           #小於計算基準日的，則為同一時距
           IF l_min_date < p_base_date THEN
              #先抓第一筆資料是為週/旬/月
              DECLARE psbe_cs1 CURSOR FOR
               SELECT psbe003 FROM psbe_t
                WHERE psbeent = g_enterprise
                  AND psbe001 = g_psba.psba001
                ORDER BY psbe002
              FOREACH psbe_cs1 INTO l_psbe003
                 EXIT FOREACH
              END FOREACH
              
              CASE l_psbe003
                 WHEN '1'   #週
                      #本日的週別
                      SELECT oogc008,oogc015 INTO l_oogc008,l_oogc015
                        FROM oogc_t
                       WHERE oogcent = g_enterprise
                         AND oogc001 = l_ooef008
                         AND oogc002 = l_ooef009
                         AND oogc003 = p_base_date
                      #本週的起始日、截止日
                      SELECT MIN(oogc003),MAX(oogc003)
                        INTO l_min,l_max
                        FROM oogc_t
                       WHERE oogcent = g_enterprise
                         AND oogc001 = l_ooef008
                         AND oogc002 = l_ooef009
                         AND oogc008 = l_oogc008
                         AND oogc015 = l_oogc015
                 WHEN '2'   #旬
                      CASE
                         WHEN DAY(p_base_date) <= 10
                              LET l_min = MDY(MONTH(p_base_date),1,YEAR(p_base_date))
                         WHEN (DAY(p_base_date) > 10 AND DAY(p_base_date) <= 20) 
                              LET l_min = MDY(MONTH(p_base_date),11,YEAR(p_base_date))
                         WHEN DAY(p_base_date) > 20
                              LET l_min = MDY(MONTH(p_base_date),21,YEAR(p_base_date))
                      END CASE
                      
                 WHEN '3'   #月
                      LET l_min = MDY(MONTH(p_base_date),1,YEAR(p_base_date))
              END CASE
              IF l_min_date < l_min THEN
                 CALL apsp400_psbb_sort1(l_min_date,l_min-1)
                      RETURNING r_success
                 LET l_min_date = l_min
              END IF
           END IF
           
           IF NOT r_success THEN
              RETURN r_success
           END IF
           
           LET l_cnt = 0
           SELECT COUNT(*) INTO l_cnt 
             FROM psbe_t
            WHERE psbeent = g_enterprise
              AND psbe001 = g_psba.psba001
           IF cl_null(l_cnt) THEN
              LET l_cnt = 0
           END IF
           
           IF l_cnt > 0 THEN
              LET l_date_t = l_min_date
              DECLARE psbe_cs CURSOR FOR
               SELECT psbe003 FROM psbe_t
                WHERE psbeent = g_enterprise
                  AND psbe001 = g_psba.psba001
                ORDER BY psbe002
                      
              LET l_cnt1 = 1
              FOREACH psbe_cs INTO l_psbe003
                 LET l_date = l_date_t
                 CASE l_psbe003
                    WHEN '1'   #週
                         #本日的週別
                         SELECT oogc008,oogc015 INTO l_oogc008,l_oogc015
                           FROM oogc_t
                          WHERE oogcent = g_enterprise
                            AND oogc001 = l_ooef008
                            AND oogc002 = l_ooef009
                            AND oogc003 = l_date
                         #本週的起始日、截止日
                         SELECT MIN(oogc003),MAX(oogc003)
                           INTO l_min,l_max
                           FROM oogc_t
                          WHERE oogcent = g_enterprise
                            AND oogc001 = l_ooef008
                            AND oogc002 = l_ooef009
                            AND oogc008 = l_oogc008
                            AND oogc015 = l_oogc015
                   WHEN '2'   #旬
                        CASE 
                           WHEN DAY(l_date) <= 10
                                LET l_min = MDY(MONTH(l_date),1,YEAR(l_date))
                                LET l_max = MDY(MONTH(l_date),10,YEAR(l_date))
                           WHEN (DAY(l_date) > 10 AND DAY(l_date) <= 20)
                                LET l_min = MDY(MONTH(l_date),11,YEAR(l_date))
                                LET l_max = MDY(MONTH(l_date),20,YEAR(l_date))
                           WHEN (DAY(l_date) > 20)
                                LET l_min = MDY(MONTH(l_date),21,YEAR(l_date))
                                CALL s_date_get_max_day(YEAR(l_date),MONTH(l_date))
                                     RETURNING l_days
                                LET l_max = MDY(MONTH(l_date),l_days,YEAR(l_date))
                         END CASE
                    WHEN '3'   #月
                         LET l_min = l_date 
                         CALL s_date_get_max_day(YEAR(l_date),MONTH(l_date))
                              RETURNING l_days
                         LET l_max = MDY(MONTH(l_date),l_days,YEAR(l_date))
                 END CASE
              
                 #依據自訂的起始日、截止日排序
                 IF l_cnt1 < l_cnt THEN
                    CALL apsp400_psbb_sort1(l_min,l_max)
                         RETURNING r_success
                 ELSE
                    CALL apsp400_psbb_sort1(l_min,l_max_date)
                         RETURNING r_success
                 END IF
                 IF NOT r_success THEN
                    EXIT FOREACH
                 END IF
                 LET l_cnt1 = l_cnt1 + 1
                 LET l_date_t = l_max + 1
              END FOREACH
           ELSE
              #將超過時間的資料視為最後一個時距
              IF l_max < l_max_date THEN
                 CALL apsp400_psbb_sort1(l_min_date,l_max_date)
                      RETURNING r_success
              END IF
           END IF
   END CASE
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="function.apsp400_psbb_sort1" cite_std="N" status="" ver="1" src="s" new="Y" order="14" mark_hard="N">
<![CDATA[
################################################################################
# Descriptions...: 由起始日到截止日，根據apsi001的需求滿足方式排序
# Memo...........:
# Usage..........: CALL apsp400_psbb_sort1(p_date1,p_date2)
#                  RETURNING r_success
# Input parameter: p_date1        起始日
#                : p_date2        截止日
# Return code....: r_success      TRUE/FALSE
#                : 
# Date & Author..: 2014/03/25 By stellar0130
# Modify.........:
################################################################################
PRIVATE FUNCTION apsp400_psbb_sort1(p_date1,p_date2)
DEFINE p_date1           LIKE type_t.dat
DEFINE p_date2           LIKE type_t.dat
DEFINE r_success         LIKE type_t.num5
DEFINE l_sql             STRING
DEFINE l_sort            STRING

   LET r_success = TRUE
   
   #抓取psbb_t資料新增到temp table
   DELETE FROM sort_tmp
   DECLARE psbb_cs CURSOR FOR
    SELECT 9,psbbdocno,psbbseq,psbbseq1,psbbseq2,psbb001,psbb002,
           psbb007,psbb008,'',''
      FROM psbb_t
     WHERE psbbent = g_enterprise
       AND psbbsite= g_site
       AND psbb001 = g_psba.psba001
       AND psbb007 BETWEEN p_date1 AND p_date2
   FOREACH psbb_cs INTO g_sort.*
      #單據排序
      IF g_psba.psba013 = g_sort.psbb002 THEN
         LET g_sort.sort1 = 1
      END IF
      IF g_psba.psba014 = g_sort.psbb002 THEN
         LET g_sort.sort1 = 2
      END IF
      IF g_psba.psba015 = g_sort.psbb002 THEN
         LET g_sort.sort1 = 3
      END IF
     
      IF NOT cl_null(g_sort.psbb008) THEN
         SELECT oocq009 INTO g_sort.oocq009
           FROM pmaa_t,oocq_t
          WHERE pmaaent = oocqent
            AND oocq001 = '286'
            AND pmaa094 = oocq002
            AND pmaaent = g_enterprise
            AND pmaa001 = g_sort.psbb008
         IF cl_null(g_sort.oocq009) THEN
            LET g_sort.oocq009 = 'A'
         END IF
      ELSE
         LET g_sort.oocq009 = 'A'
      END IF
      
      #若單據類型非訂單的，則緊急度=1.一般
      IF g_sort.psbb002 = '1' THEN
         SELECT xmdc020 INTO g_sort.xmdc020
           FROM xmdc_t
          WHERE xmdcent = g_enterprise
            AND xmdcdocno = g_sort.psbbdocno
            AND xmdcseq = g_sort.psbbseq
         IF SQLCA.sqlcode THEN
            CALL cl_errmsg("sel xmdc020",g_sort.psbbdocno||','||g_sort.psbbseq,"",SQLCA.sqlcode,1)
            LET r_success = FALSE
           EXIT FOREACH
         END IF
      ELSE
         LET g_sort.xmdc020 = '1'
      END IF
         
      INSERT INTO sort_tmp VALUES (g_sort.*)
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg("ins sort","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   LET l_sort = ""
   CASE g_psba.psba017
      WHEN '1' 
           LET l_sort = "xmdc020"
      WHEN '2'
           LET l_sort = "psbb007"
      WHEN '3' 
           LET l_sort = "oocq009"
   END CASE
   
   CASE g_psba.psba018
      WHEN '1' 
           LET l_sort = l_sort,",xmdc020"
      WHEN '2'
           LET l_sort = l_sort,",psbb007"
      WHEN '3' 
           LET l_sort = l_sort,",oocq009"
   END CASE
   
   CASE g_psba.psba019
      WHEN '1' 
           LET l_sort = l_sort,",xmdc020"
      WHEN '2'
           LET l_sort = l_sort,",psbb007"
      WHEN '3' 
           LET l_sort = l_sort,",oocq009"
   END CASE
   
   
   LET l_sql = "SELECT * FROM sort_tmp "
   
   IF g_psba.psba006 = '1' THEN
      LET l_sql = l_sql CLIPPED," ORDER BY sort1,",l_sort CLIPPED
   ELSE
      LET l_sql = l_sql CLIPPED," ORDER BY ",l_sort CLIPPED,",sort1"
   END IF
   
   PREPARE sort_tmp_pre FROM l_sql
   DECLARE sort_tmp_cs CURSOR FOR sort_tmp_pre
   
   FOREACH sort_tmp_cs INTO g_sort.*
      IF SQLCA.sqlcode THEN
         CALL cl_errmsg("FOREACH sort_tmp_cs","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   
      LET g_psbb_sort = g_psbb_sort + 10
      UPDATE psbb_t SET psbb012 = g_psbb_sort
       WHERE psbbent = g_enterprise
         AND psbbsite= g_site
         AND psbbdocno = g_sort.psbbdocno
         AND psbbseq = g_sort.psbbseq
         AND psbbseq1= g_sort.psbbseq1
         AND psbbseq2= g_sort.psbbseq2
         AND psbb001 = g_sort.psbb001
      IF SQLCA.sqlcode OR SQLCA.sqlerrd[3] = 0 THEN
         CALL cl_errmsg("upd psbb_t","","",SQLCA.sqlcode,1)
         LET r_success = FALSE
         EXIT FOREACH
      END IF
   END FOREACH
   
   RETURN r_success
END FUNCTION]]>
</point>
  <point name="global.parameter" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   psba001               LIKE psba_t.psba001,
   base_date             LIKE type_t.dat,]]>
</point>
  <point name="global.variable" cite_std="N" status="u" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[DEFINE l_ac              LIKE type_t.num5
DEFINE g_ref_fields      DYNAMIC ARRAY OF VARCHAR(500) #ap_ref用陣列
DEFINE g_ref_vars        DYNAMIC ARRAY OF VARCHAR(500) #ap_ref用陣列
DEFINE g_rtn_fields      DYNAMIC ARRAY OF VARCHAR(500) #ap_ref用陣列
DEFINE g_target          STRING

 type type_g_forecast      RECORD
        xmig001          LIKE xmig_t.xmig001,   #預測編號
        xmig002          LIKE xmig_t.xmig002,   #預測起始日
        xmig003          LIKE xmig_t.xmig003,   #預測版本
        xmig004          LIKE xmig_t.xmig004,   #預測組織
        xmig005          LIKE xmig_t.xmig005,   #業務員
        xmig006          LIKE xmig_t.xmig006,   #預測料號
        xmig007          LIKE xmig_t.xmig007,   #產品特徵
        xmig008          LIKE xmig_t.xmig008,   #客戶
        xmig009          LIKE xmig_t.xmig009,   #通路
        xmig010          LIKE xmig_t.xmig010,   #期別
        xmig011          LIKE xmig_t.xmig011,   #起始日
        xmig012          LIKE xmig_t.xmig012,   #截止日
        quantity         LIKE xmig_t.xmig013,   #預測數量-業務預測數量/生管確認數量
        xmig017          LIKE xmig_t.xmig017,   #預測類型
        xmig018          LIKE xmig_t.xmig018    #單位
                         END RECORD
                         
 type type_g_order         RECORD
        xmdadocno        LIKE xmda_t.xmdadocno, #單號
        xmda002          LIKE xmda_t.xmda002,   #業務員
        xmda003          LIKE xmda_t.xmda003,   #銷售組織
        xmda004          LIKE xmda_t.xmda004,   #客戶
        xmda023          LIKE xmda_t.xmda023,   #通路
        xmddseq          LIKE xmdd_t.xmddseq,   #項次
        xmddseq1         LIKE xmdd_t.xmddseq1,  #項序
        xmddseq2         LIKE xmdd_t.xmddseq2,  #分批序
        xmdd001          LIKE xmdd_t.xmdd001,   #料號
        xmdd002          LIKE xmdd_t.xmdd002,   #產品特徵
        xmdd004          LIKE xmdd_t.xmdd004,   #單位
        quantity         LIKE xmdd_t.xmdd006,   #數量
        xmdd011          LIKE xmdd_t.xmdd011,   #需求日期
        xmdd013          LIKE xmdd_t.xmdd013    #嚴守交期
                         END RECORD
type type_g_sort         RECORD
        sort1            LIKE type_t.num5,      #單據排序
        psbbdocno        LIKE psbb_t.psbbdocno, #單據編號
        psbbseq          LIKE psbb_t.psbbseq,   #項次
        psbbseq1         LIKE psbb_t.psbbseq1,  #項序
        psbbseq2         LIKE psbb_t.psbbseq2,  #分批序
        psbb001          LIKE psbb_t.psbb001,   #MDS編號
        psbb002          LIKE psbb_t.psbb002,   #單據類型
        psbb007          LIKE psbb_t.psbb007,   #需求日期
        psbb008          LIKE psbb_t.psbb008,   #客戶
        oocq009          LIKE oocq_t.oocq009,   #客戶重要性
        xmdc020          LIKE xmdc_t.xmdc020    #緊急度
                         END RECORD
                         
DEFINE g_forecast        type_g_forecast
DEFINE g_order           type_g_order
DEFINE g_sort            type_g_sort
DEFINE g_psba            RECORD LIKE psba_t.*
DEFINE g_order_day       DYNAMIC ARRAY OF RECORD
         date            LIKE type_t.dat,       #訂單需求日
         qty             LIKE psbb_t.psbb006    #訂單需求量
                         END RECORD
DEFINE g_psbb_sort       LIKE type_t.num10
DEFINE g_psbe            DYNAMIC ARRAY OF RECORD
         psbe002         LIKE psbe_t.psbe002,
         psbe003         LIKE psbe_t.psbe003
                         END RECORD]]>
</point>
  <point name="init.init" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   LET g_errshow = 1
   CALL cl_set_combo_scc('psba008','5402')
   CALL cl_set_combo_scc('psba009','5403')
   CALL cl_set_combo_scc('psba011','8016')
   CALL cl_set_combo_scc('psba006','5420')
   CALL cl_set_combo_scc('psba013','5404')
   CALL cl_set_combo_scc('psba014','5404')
   CALL cl_set_combo_scc('psba015','5404')
   CALL cl_set_combo_scc('psba017','5405')
   CALL cl_set_combo_scc('psba018','5405')
   CALL cl_set_combo_scc('psba019','5405')
   CALL cl_set_combo_scc('psba016','5421')
   CALL cl_set_combo_scc('psba020','5406')
   CALL cl_set_combo_scc('psba021','5407')
   CALL cl_set_combo_scc('psba023','5408')
   CALL cl_set_combo_scc_part('psbe003','5421','1,2,3')
   IF cl_null(g_bgjob) THEN
      LET g_bgjob = 'N'
   END IF
   LET g_errshow = 1]]>
</point>
  <point name="process.count_progress" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[      LET li_count = 6
      CALL cl_progress_bar_no_window(li_count)]]>
</point>
  <point name="process.define" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   DEFINE l_success   LIKE type_t.num5
   DEFINE l_msg       STRING]]>
</point>
  <point name="process.foreground_finish" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[      IF NOT l_success THEN
         CALL cl_showmsg()
      END IF]]>
</point>
  <point name="process.pre_process" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   INITIALIZE g_psba.* TO NULL
   SELECT * INTO g_psba.* 
     FROM psba_t
    WHERE psbaent = g_enterprise
      AND psba001 = lc_param.psba001
   IF SQLCA.sqlcode THEN
      CALL cl_err(lc_param.psba001,SQLCA.sqlcode,1)
      RETURN
   END IF

   IF NOT apsp400_create_temptable() THEN
      RETURN
   END IF]]>
</point>
  <point name="process.process" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   CALL s_transaction_begin()
   CALL cl_showmsg_init()
   LET l_success = TRUE
   
   #刪除MDS舊有資料(psbb_t、psbc_t、psbd_t)
   #part1
   IF g_bgjob <> "Y" THEN
      LET l_msg = cl_getmsg('aps-00060',g_dlang)
      CALL cl_progress_no_window_ing(l_msg)
   END IF
   IF NOT apsp400_del_mds() THEN
      LET l_success = FALSE
   END IF
   
   #取得銷售預測資料
   #part2
   IF l_success THEN
      IF g_bgjob <> "Y" THEN
         LET l_msg = cl_getmsg('aps-00064',g_dlang)
         CALL cl_progress_no_window_ing(l_msg)
      END IF
      CALL apsp400_get_forecast(lc_param.base_date)
           RETURNING l_success
   END IF
   
   #取得訂單資料
   #part3
   IF l_success THEN
      IF g_bgjob <> "Y" THEN
         LET l_msg = cl_getmsg('aps-00065',g_dlang)
         CALL cl_progress_no_window_ing(l_msg)
      END IF
      CALL apsp400_get_order(lc_param.base_date)
           RETURNING l_success
   END IF
   
   #預測與訂單沖銷
   #part4
   IF l_success THEN
      IF g_bgjob <> "Y" THEN
         LET l_msg = cl_getmsg('aps-00066',g_dlang)
         CALL cl_progress_no_window_ing(l_msg)
      END IF
      #當銷售預測及訂單都有勾選時，就要依據預測與訂單沖銷方式來做沖銷
      IF g_psba.psba002 = 'Y' AND (g_psba.psba003 = 'Y' OR g_psba.psba004 = 'Y') THEN
         #預測與訂單沖銷方式
         CASE g_psba.psba008
            WHEN '0'
                 #只考量訂單
                 #直接抓取訂單資料寫入MDS淨需求檔(psbb_t)
                 CALL apsp400_order_ins_psbb()
                      RETURNING l_success
            WHEN '1'
                 #只考量預測
                 #計算預測資料分配到天，並寫入MDS淨需求檔(psbb_t)
                 DECLARE forecast_cs1 CURSOR FOR 
                  SELECT * FROM forecast_tmp
                 FOREACH forecast_cs1 INTO g_forecast.*
                    CALL apsp400_apportion(g_forecast.quantity,0)
                         RETURNING l_success
                    IF NOT l_success THEN
                       EXIT FOREACH
                    END IF
                 END FOREACH
            WHEN '2'
                 #兩者取其大
                 CALL apsp400_contra(lc_param.base_date)
                      RETURNING l_success
         END CASE
      ELSE
         #只有銷售預測勾選
         IF g_psba.psba002 = 'Y' THEN
            #計算預測資料分配到天，並寫入MDS淨需求檔(psbb_t)
            DECLARE forecast_cs2 CURSOR FOR 
             SELECT * FROM forecast_tmp
            FOREACH forecast_cs2 INTO g_forecast.*
               CALL apsp400_apportion(g_forecast.quantity,0)
                    RETURNING l_success
               IF NOT l_success THEN
                  EXIT FOREACH
               END IF
            END FOREACH
         END IF
      
         #只有訂單/預先訂單勾選
         IF g_psba.psba003 = 'Y' OR g_psba.psba004 = 'Y' THEN
            #直接抓取訂單資料寫入MDS淨需求檔(psbb_t)
            CALL apsp400_order_ins_psbb()
                 RETURNING l_success
         END IF
      END IF
   END IF
   
   #獨立需求
   #part5
   IF l_success THEN
      IF g_bgjob <> "Y" THEN
         LET l_msg = cl_getmsg('aps-00067',g_dlang)
         CALL cl_progress_no_window_ing(l_msg)
      END IF
      IF g_psba.psba005 = 'Y' THEN
         CALL apsp400_independent_demand()
              RETURNING l_success
      END IF
   END IF
   
   #排列優先順序
   #part6
   IF l_success THEN
      IF g_bgjob <> "Y" THEN
         LET l_msg = cl_getmsg('aps-00068',g_dlang)
         CALL cl_progress_no_window_ing(l_msg)
      END IF
      CALL apsp400_psbb_sort(lc_param.base_date)
           RETURNING l_success
   END IF
   
   IF l_success THEN
      CALL s_transaction_end('Y','0')
   ELSE
      CALL s_transaction_end('N','0')
   END IF]]>
</point>
  <point name="transfer.argv.define" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[   LET la_cmdrun.param[1] = la_param.psba001
   LET la_cmdrun.param[2] = la_param.base_date]]>
</point>
  <point name="ui_dialog.define" cite_std="N" status="" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[

   INITIALIZE lc_param.* TO NULL
   LET lc_param.base_date = g_today]]>
</point>
  <point name="ui_dialog.more_input" cite_std="N" status="u" ver="1" src="s" new="N" order="" mark_hard="N">
<![CDATA[         INPUT lc_param.psba001,lc_param.base_date FROM psba001,base_date
               ATTRIBUTE(WITHOUT DEFAULTS)
            BEFORE INPUT
               LET lc_param.base_date = g_today
               DISPLAY BY NAME lc_param.base_date
            
            AFTER FIELD psba001
               CALL apsp400_psba001_ref(lc_param.psba001) 
               IF NOT cl_null(lc_param.psba001) THEN
                  IF NOT apsp400_psba001_chk(lc_param.psba001) THEN
                     NEXT FIELD CURRENT
                  END IF
               END IF
            
            ON ACTION controlp INFIELD psba001
               INITIALIZE g_qryparam.* TO NULL
               LET g_qryparam.state = 'i'
               LET g_qryparam.reqry = FALSE
               LET g_qryparam.default1 = lc_param.psba001
               CALL q_psba001()
               LET lc_param.psba001 = g_qryparam.return1
               DISPLAY lc_param.psba001 TO psba001
               
               CALL apsp400_psba001_ref(lc_param.psba001)
               
               NEXT FIELD psba001
         END INPUT
         ]]>
</point>
  <point name="global.memo" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="global.import" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="global.argv" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="main.define" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="main.background" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="main.servicecall" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="main.before_close" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="main.exit" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="init.define" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="ui_dialog.before_dialog" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="ui_dialog.more_construct" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="ui_dialog.more_displayarray" cite_std="N" status="u" ver="" src="s" new="Y">
<![CDATA[         DISPLAY ARRAY g_psbe TO s_detail1.* ATTRIBUTES(COUNT=l_ac)
            BEFORE DISPLAY
         END DISPLAY ]]>
</point>
  <point name="ui_dialog.qbe_select" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="ui_dialog.more_action" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="process.exit_dialog" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <point name="process.background_finish" cite_std="N" status="" ver="" src="s" new="Y">
<![CDATA[]]>
</point>
  <section id="apsp400.description" ver="133" status="" src="s">
<![CDATA[#+ Version..: T100-ERP-1.00.00(SD版次:1,PD版次:1) Build-000132
#+ 
#+ Filename...: apsp400
#+ Description: MDS匯總計算作業
#+ Creator....: 01588(2014/03/13)
#+ Modifier...: 01588(2014/03/17)
#+ Buildtype..: 應用 p01 樣板自動產生
#+ 以上段落由子樣板a00產生
]]>
</section>
  <section id="apsp400.global" ver="3" status="" src="s">
<![CDATA[{<point name="global.memo" />}
 
IMPORT os
IMPORT util
IMPORT FGL lib_cl_schedule
#add-point:增加匯入項目
{<point name="global.import" />}
#end add-point
 
SCHEMA ds
 
GLOBALS "../../cfg/top_global.inc"
GLOBALS "../../cfg/top_schedule.inc"
GLOBALS
   DEFINE gwin_curr2  ui.Window
   DEFINE gfrm_curr2  ui.Form
   DEFINE gi_hiden_asign       LIKE type_t.num5
   DEFINE gi_hiden_exec        LIKE type_t.num5
   DEFINE gi_hiden_spec        LIKE type_t.num5
   DEFINE gi_hiden_exec_end    LIKE type_t.num5
END GLOBALS
 
PRIVATE TYPE type_parameter RECORD
   #add-point:自定背景執行須傳遞的參數(Module Variable)
   {<point name="global.parameter"/>}
   #end add-point
        wc               STRING
                     END RECORD
 
DEFINE g_sql             STRING        #組 sql 用
DEFINE g_forupd_sql      STRING        #SELECT ... FOR UPDATE  SQL
DEFINE g_error_show      LIKE type_t.num5
DEFINE g_jobid           STRING
 
#add-point:自定義模組變數(Module Variable)
{<point name="global.variable"/>}
#end add-point
 
#add-point:傳入參數說明
{<point name="global.argv"/>}
#end add-point
]]>
</section>
  <section id="apsp400.init" ver="4" status="" src="s">
<![CDATA[#+ 初始化作業
PRIVATE FUNCTION apsp400_init()
   #add-point:init段define
   {<point name="init.define"/>}
   #end add-point
 
   LET g_error_show = 1
   LET gwin_curr2 = ui.Window.getCurrent()
   LET gfrm_curr2 = gwin_curr2.getForm()
   CALL cl_schedule_import_4fd()
   CALL cl_set_combo_scc("gzpa003","75")
   IF cl_get_para(g_enterprise,"","E-SYS-0005") = "N" THEN
       CALL cl_set_comp_visible("scheduling_page,history_page",FALSE)
   END IF 
   #add-point:畫面資料初始化
   {<point name="init.init" />}
   #end add-point
   
END FUNCTION
]]>
</section>
  <section id="apsp400.main" ver="2" status="" src="s">
<![CDATA[MAIN
   DEFINE ls_js    STRING
   DEFINE lc_param type_parameter  
   #add-point:main段define
   {<point name="main.define"/>}
   #end add-point 
  
   #設定SQL錯誤記錄方式 (模組內定義有效)
   WHENEVER ERROR CALL cl_err_msg_log
 
   #依模組進行系統初始化設定(系統設定)
   CALL cl_ap_init("aps","")
 
   #add-point:定義背景狀態與整理進入需用參數ls_js
   {<point name="main.background"/>}
   #end add-point
 
   IF g_bgjob = "Y" THEN
      #add-point:Service Call
      {<point name="main.servicecall" />}
      #end add-point
      CALL apsp400_process(ls_js)
   ELSE
      #畫面開啟 (identifier)
      OPEN WINDOW w_apsp400 WITH FORM cl_ap_formpath("aps",g_code)
 
      #瀏覽頁簽資料初始化
      CALL cl_ui_init()
 
      #程式初始化
      CALL apsp400_init()
 
      #進入選單 Menu (="N")
      CALL apsp400_ui_dialog()
 
      #add-point:畫面關閉前
      {<point name="main.before_close" />}
      #end add-point
      #畫面關閉
      CLOSE WINDOW w_apsp400
   END IF
 
   #add-point:作業離開前
   {<point name="main.exit" />}
   #end add-point
 
   #離開作業
   CALL cl_ap_exitprogram("0")
END MAIN
]]>
</section>
  <section id="apsp400.other_function" ver="1" status="" src="s">
<![CDATA[#add-point:自定義元件(Function)
{<point name="other.function"/>}
#end add-point
]]>
</section>
  <section id="apsp400.process" ver="1" status="" src="s">
<![CDATA[#+ 資料處理
PRIVATE FUNCTION apsp400_process(ls_js)
   DEFINE ls_js       STRING
   DEFINE lc_param    type_parameter
   DEFINE li_stus     LIKE type_t.num5
   DEFINE li_count    LIKE type_t.num10  #progressbar計量
   DEFINE ls_sql      STRING             #主SQL
   #add-point:process段define
   {<point name="process.define"/>}
   #end add-point
 
   CALL util.JSON.parse(ls_js,lc_param)
 
   #add-point:process段前處理
   {<point name="process.pre_process"/>}
   #end add-point
 
   #預先計算progressbar迴圈次數
   IF g_bgjob <> "Y" THEN
      #add-point:process段count_progress
      {<point name="process.count_progress"/>}
      #end add-point
   END IF
 
   #主SQL及相關FOREACH前置處理
#  DECLARE apsp400_process_cs CURSOR FROM ls_sql
#  FOREACH apsp400_process_cs INTO
   #add-point:process段process
   {<point name="process.process"/>}
   #end add-point
#  END FOREACH
 
   IF g_bgjob = "N" THEN
      #前景作業完成處理
      #add-point:process段foreground完成處理
      {<point name="process.foreground_finish"/>}
      #end add-point
      CALL cl_ask_confirm("std-00012") RETURNING li_stus
   ELSE
      #背景作業完成處理
      #add-point:process段background完成處理
      {<point name="process.background_finish"/>}
      #end add-point
   END IF
END FUNCTION
]]>
</section>
  <section id="apsp400.transfer_argv" ver="1" status="" src="s">
<![CDATA[#+ 轉換本地參數至cmdrun參數內,準備進入背景執行
PRIVATE FUNCTION apsp400_transfer_argv(ls_js)
   DEFINE ls_js       STRING
   DEFINE la_cmdrun   RECORD
             prog     STRING,
             param    DYNAMIC ARRAY OF STRING
                  END RECORD
   DEFINE la_param    type_parameter
 
   CALL util.JSON.parse(ls_js,la_param)
 
   LET la_cmdrun.prog = g_prog
   #add-point:transfer.argv段define
   {<point name="transfer.argv.define"/>}
   #end add-point
 
   RETURN util.JSON.stringify( la_cmdrun )
END FUNCTION
]]>
</section>
  <section id="apsp400.ui_dialog" ver="8" status="" src="s">
<![CDATA[#+ 選單功能實際執行處
PRIVATE FUNCTION apsp400_ui_dialog()
   DEFINE li_exit  LIKE type_t.num5    #判別是否為離開作業
   DEFINE li_idx   LIKE type_t.num5
   DEFINE ls_js    STRING
   DEFINE ls_wc    STRING
   DEFINE lc_param type_parameter
   #add-point:ui_dialog段define
   {<point name="ui_dialog.define"/>}
   #end add-point
 
   #add-point:ui_dialog段before dialog
   {<point name="ui_dialog.before_dialog"/>}
   #end add-point
 
   WHILE TRUE
      DIALOG ATTRIBUTES(UNBUFFERED,FIELD ORDER FORM)
         #add-point:ui_dialog段construct
         {<point name="ui_dialog.more_construct"/>}
         #end add-point
         #add-point:ui_dialog段input
         {<point name="ui_dialog.more_input"/>}
         #end add-point
         #add-point:ui_dialog段自定義display array
         {<point name="ui_dialog.more_displayarray"/>}
         #end add-point
 
         SUBDIALOG lib_cl_schedule.cl_schedule_setting
         SUBDIALOG lib_cl_schedule.cl_schedule_setting_exec_call
         SUBDIALOG lib_cl_schedule.cl_schedule_select_show_history
         SUBDIALOG lib_cl_schedule.cl_schedule_show_history
 
         ON ACTION qbe_select
            CALL cl_qbe_list("m") RETURNING ls_wc
            IF NOT cl_null(ls_wc) THEN
               LET lc_param.wc = ls_wc
               #取得條件後需要執行項目,應新增於下方adp
               #add-point:ui_dialog段qbe_select後
               {<point name="ui_dialog.qbe_select"/>}
               #end add-point
            END IF
 
         ON ACTION qbe_save
            CALL cl_qbe_save()
 
         ON ACTION batch_execute
            ACCEPT DIALOG
 
         ON ACTION qbeclear         
            CLEAR FORM
            INITIALIZE lc_param.*  TO NULL
 
         ON ACTION history_fill
            CALL cl_schedule_history_fill()
 
         ON ACTION CLOSE 
            LET INT_FLAG = TRUE
            EXIT DIALOG
         
         ON ACTION exit
            LET INT_FLAG = TRUE
            EXIT DIALOG
 
         #add-point:ui_dialog段action
         {<point name="ui_dialog.more_action"/>}
         #end add-point
 
         #主選單用ACTION
         &include "main_menu.4gl"
         &include "relating_action.4gl"
         #交談指令共用ACTION
         &include "common_action.4gl"
            CONTINUE DIALOG
      END DIALOG
 
      #add-point:ui_dialog段exit dialog
      {<point name="process.exit_dialog"/>}
      #end add-point
 
      LET ls_js = util.JSON.stringify(lc_param)
 
      IF INT_FLAG THEN
         LET INT_FLAG = FALSE
         EXIT WHILE
      ELSE
         LET g_jobid = g_prog,TODAY USING "yyyymmdd",CURRENT HOUR TO SECOND 
         LET g_jobid = cl_schedule_trim_colon(g_jobid)
         CASE 
            WHEN g_schedule.gzpa003 = "0"
                 CALL apsp400_process(ls_js)
            WHEN g_schedule.gzpa003 = "1"
                 CALL cl_schedule_update_data(g_jobid)
                 LET ls_js = apsp400_transfer_argv(ls_js)
                 CALL cl_cmdrun(ls_js)
            WHEN g_schedule.gzpa003 = "2"
                 CALL cl_schedule_update_data(g_jobid)
            WHEN g_schedule.gzpa003 = "3"
                 CALL cl_schedule_update_data(g_jobid)
         END CASE    
         LET g_schedule.gzpa003 = "0" #預設一開始 立即於前景執行
         INITIALIZE lc_param.*  TO NULL 
         #欄位初始資訊 
         CALL cl_schedule_init_info("all",g_schedule.gzpa003) 
         LET gi_hiden_asign = FALSE 
         LET gi_hiden_exec = FALSE 
         LET gi_hiden_spec = FALSE 
         LET gi_hiden_exec_end = FALSE 
         CALL cl_schedule_hidden()
      END IF
   END WHILE
 
END FUNCTION
]]>
</section>
</add_points>